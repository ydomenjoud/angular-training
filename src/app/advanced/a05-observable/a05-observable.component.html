<h1>Observable</h1>

<h2>Returning Observable</h2>

<section>
  <ul>
    <li>New Observable()</li>
    <li>EventEmitter class extends Observable.</li>
    <li>HTTP module uses observables to handle AJAX requests and responses.</li>
    <li>Router and Forms modules use observables to listen for and respond to user-input events.</li>
  </ul>
</section>

<h2>Basic Syntax</h2>
<section class="code">
  <article>
    <code appHighlight [code]="componentCode" [expanded]="true"></code>
  </article>
  <article>
    <input type="text" #todoName (keyup.enter)="addTodo(todoName.value)">
    <button (click)="addTodo(todoName.value)">Add Todo</button>

    Last action
    <ng-container *ngIf="(todoAdded$ | async) as todo">
      <p>
        Last todo added {{ todo.message }}
      </p>
      <ul>
        <li
          *ngFor="let element of (todo|keyvalue)"
        >{{ element | json}}
        </li>
      </ul>
    </ng-container>
  </article>
</section>

<h2>Creating observable</h2>
<section class="code">
  <article>
    <code appHighlight [code]="creatingObservablecode" [expanded]="true"></code>
  </article>
  <article>
    <button (click)="startCounter()">Start Counter</button>
    <ul>
      <li>value: {{ counterValue }}</li>
      <li>state: {{ counterState}}</li>
    </ul>
  </article>
</section>

<h2>Operators</h2>

<section class="flex">
  <article>
    <h3>Creation</h3>
    <ul appLearnxjsContainer="creation">
      <li><a appLearnxjs>create</a></li>
      <li><a appLearnxjs>empty</a></li>
      <li><a appLearnxjs>from</a></li>
      <li><a appLearnxjs>fromEvent</a></li>
      <li><a appLearnxjs>interval</a></li>
      <li><a appLearnxjs>of</a></li>
      <li><a appLearnxjs>range</a></li>
      <li><a appLearnxjs>throw</a></li>
      <li><a appLearnxjs>timer</a></li>
    </ul>

  </article>
  <article>
    <h3>Combination</h3>
    <ul appLearnxjsContainer="combination">
      <li><a appLearnxjs>combineAll</a></li>
      <li><a appLearnxjs>combineLatest</a></li>
      <li><a appLearnxjs>concat</a></li>
      <li><a appLearnxjs>concatAll</a></li>
      <li><a appLearnxjs>forkJoin</a></li>
      <li><a appLearnxjs>merge</a></li>
      <li><a appLearnxjs>mergeAll</a></li>
      <li><a appLearnxjs>pairwise</a></li>
      <li><a appLearnxjs>race</a></li>
      <li><a appLearnxjs>startWith</a></li>
      <li><a appLearnxjs>withLatestFrom</a></li>
      <li><a appLearnxjs>zip</a></li>
    </ul>
  </article>
  <article>
    <h3>Filtering</h3>
    <ul appLearnxjsContainer="filtering">
      <li><a appLearnxjs>audit</a></li>
      <li><a appLearnxjs>auditTime</a></li>
      <li><a appLearnxjs>debounce</a></li>
      <li><a appLearnxjs>debounceTime</a></li>
      <li><a appLearnxjs>distinctUntilChanged</a></li>
      <li><a appLearnxjs>filter</a></li>
      <li><a appLearnxjs>first</a></li>
      <li><a appLearnxjs>ignoreElements</a></li>
      <li><a appLearnxjs>last</a></li>
      <li><a appLearnxjs>sample</a></li>
      <li><a appLearnxjs>single</a></li>
      <li><a appLearnxjs>skip</a></li>
      <li><a appLearnxjs>skipUntil</a></li>
      <li><a appLearnxjs>skipWhile</a></li>
      <li><a appLearnxjs>take</a></li>
      <li><a appLearnxjs>takeUntil</a></li>
      <li><a appLearnxjs>takeWhile</a></li>
      <li><a appLearnxjs>throttle</a></li>
      <li><a appLearnxjs>throttleTime</a></li>
    </ul>
  </article>
  <article>
    <h3>Transformation</h3>
    <ul appLearnxjsContainer="transformation">
      <li><a appLearnxjs>buffer</a></li>
      <li><a appLearnxjs>bufferCount</a></li>
      <li><a appLearnxjs>bufferTime</a></li>
      <li><a appLearnxjs>bufferToggle</a></li>
      <li><a appLearnxjs>bufferWhen</a></li>
      <li><a appLearnxjs>concatMap</a></li>
      <li><a appLearnxjs>concatMapTo</a></li>
      <li><a appLearnxjs>exhaustMap</a></li>
      <li><a appLearnxjs>expand</a></li>
      <li><a appLearnxjs>groupBy</a></li>
      <li><a appLearnxjs>map</a></li>
      <li><a appLearnxjs>mapTo</a></li>
      <li><a appLearnxjs>mergeMap</a></li>
      <li><a appLearnxjs>partition</a></li>
      <li><a appLearnxjs>pluck</a></li>
      <li><a appLearnxjs>reduce</a></li>
      <li><a appLearnxjs>scan</a></li>
      <li><a appLearnxjs>switchMap</a></li>
      <!--<li><a appLearnxjs>window</a></li>-->
      <!--<li><a appLearnxjs>windowCount</a></li>-->
      <!--<li><a appLearnxjs>windowTime</a></li>-->
      <!--<li><a appLearnxjs>windowToggle</a></li>-->
      <!--<li><a appLearnxjs>windowWhen</a></li>-->
    </ul>
  </article>
</section>


<h2>Advanced Syntax</h2>
<section class="code">
  <article>
    <code appHighlight [code]="component2Code" [expanded]="true"></code>
  </article>
  <article>
  </article>
</section>

<h2>Subject</h2>

<p>
  <strong>What is a Subject?</strong><br/>
  An RxJS Subject is a special type of Observable that allows values to be multicasted to many Observers. While plain
  Observables are unicast (each subscribed Observer owns an independent execution of the Observable), Subjects are
  multicast.</p>
<p>A Subject is like an Observable, but can multicast to many Observers. Subjects are like EventEmitters: they maintain
  a registry of many listeners.</p>

<p><strong>Every Subject is an Observable.</strong> Given a Subject, you can <code>subscribe</code> to it, providing an
  Observer,
  which will start receiving values normally. From the perspective of the Observer, it cannot tell whether the
  Observable execution is coming from a plain unicast Observable or a Subject.</p>

<p><strong>Every Subject is an Observer.</strong> It is an object with the methods <code>next(v), error(e), and
  complete()</code>. To feed a new value to the Subject, just call next(theValue), and it will be multicasted to the
  Observers registered to listen to the Subject.</p>


<h2>Kind of Subjects</h2>
<h3>Subject</h3>
<p>Basic subject</p>

<h3>BehaviorSubject</h3>
<p>One of the variants of Subjects is the BehaviorSubject, which has a notion of "the current value". It stores the
  latest value emitted to its consumers, and whenever a new Observer subscribes, it will immediately receive the
  "current value" from the BehaviorSubject</p>

<h3>ReplaySubject</h3>
<p>A ReplaySubject is similar to a BehaviorSubject in that it can send old values to new subscribers, but it can also
  record a part of the Observable execution.
  A ReplaySubject records multiple values from the Observable execution and replays them to new subscribers.
</p>

<section class="code">
  <article>
    <code appHighlight [code]="replaySubjectCode" [expanded]="false"></code>
  </article>
  <article>
  </article>
</section>


<h3>AsyncSubject</h3>
<p>The AsyncSubject is a variant where only the last value of the Observable execution is sent to its observers, and
  only when the execution completes.</p>
<p>The AsyncSubject is similar to the <code>last()</code> operator, in that it waits for the complete notification in
  order to deliver a single value.</p>


<h3>Unsubscribe</h3>

<p>Manually unsubscribe from all custom Observables when a component/directive gets destroyed. The best place to
  unsubscribe is inside functions that handle the OnDestroy lifecycle hook. Some subscriptions like router and http
  donâ€™t need manual unsubscribe, for the rest of them there are various solutions:</p>

<ul>
  <li>execute unsubscribe over the subscription object</li>
  <li>using takeUntil operator</li>
  <li>using async pipe</li>
</ul>

<h2>Examples</h2>
<h3>Progress bar</h3>
<button (click)="displayBar = !displayBar">
  toggle bar
</button>
<app-countdown *ngIf="displayBar"></app-countdown>

<app-select-number></app-select-number>

<app-select-number-timeout></app-select-number-timeout>

<app-save-cancel></app-save-cancel>
